# Copyright (c) 2023-Present Perraco Labs. All rights reserved.
# This work is licensed under the terms of the MIT license.
# For a copy, see <https://opensource.org/licenses/MIT>

# Ktor server security configuration.
ktor {
	security {
		# https://ktor.io/docs/ssl.html
		# https://ktor.io/docs/ssl.html#configure-ssl-ktor
		ssl {
			keyStore: "./keystore.p12"
			keyStore: ${?KCRUD_SECURITY_SSL_KEY_STORE}

			keyStoreType: "PKCS12"
			keyStoreType: ${?KCRUD_SECURITY_SSL_KEY_STORE_TYPE}

			keyAlias: "kcrud"
			keyAlias: ${?KCRUD_SECURITY_SSL_KEY_ALIAS}

			keyStorePassword: "kcrud"
			keyStorePassword: ${?KCRUD_SECURITY_SSL_KEY_STORE_PASSWORD}

			privateKeyPassword: "kcrud"
			privateKeyPassword: ${?KCRUD_SECURITY_SSL_PRIVATE_KEY_PASSWORD}
		}
	}
}

# Kcrud security configuration.
security {
	# Whether to enable the Basic and JWT Authentication.
	isEnabled: true
	isEnabled: ${?KCRUD_SECURITY_ENABLED}

	# When true, it enables the 'HttpsRedirect' to redirect all HTTP requests to the HTTPS counterpart
	# before processing any call, and the 'HSTS' plugin to add the required HTTP Strict Transport Security
	# headers to all the requests.
	useSecureConnection: false
	useSecureConnection: ${?KCRUD_SECURITY_SECURE_CONNECTION}

	rbac {
		# For RBAC to work it is required to have a valid JWT token
		# in the Authorization header, and JWT authentication enabled.
		isEnabled: true
		isEnabled: ${?KCRUD_SECURITY_RBAC_ENABLED}
	}

	jwt {
		providerName: "kcrud-jwt-auth"
		providerName: ${?KCRUD_SECURITY_JWT_PROVIDER_NAME}

		tokenLifetimeSec: 86400 # 1 day, (seconds).
		tokenLifetimeSec: ${?KCRUD_SECURITY_JWT_TOKEN_LIFETIME_SEC}

		audience: "Kcrud"
		audience: ${?KCRUD_SECURITY_JWT_AUDIENCE}

		realm: "kcrud"
		realm: ${?KCRUD_SECURITY_JWT_REALM}

		issuer: "localhost"
		issuer: ${?KCRUD_SECURITY_JWT_ISSUER}

		secretKey: "kcrud-secret"
		secretKey: ${?KCRUD_SECURITY_JWT_SECRET_KEY}
	}

	basic {
		providerName: "kcrud-basic-auth"
		providerName: ${?KCRUD_SECURITY_BASIC_AUTH_PROVIDER_NAME}

		realm: "kcrud"
		realm: ${?KCRUD_SECURITY_BASIC_AUTH_REALM}
	}

	# Attributes for field level encryption.
	# If any of these values are changed after data has already been encrypted,
	# any previously encrypted field will not be able to be decrypted.
	# So, ideally, these values should be set before any data is inputed into
	# the application, and should not be changed after that.
	# If the attributes are compromised, then the data should be decrypted with
	# the old attributes and then re-encrypted with the new ones.
	encryption {
		# Choices: "AES_256_PBE_CBC", "AES_256_PBE_GCM", "BLOW_FISH", "TRIPLE_DES"
		algorithm: "AES_256_PBE_CBC"
		algorithm: ${?KCRUD_SECURITY_ENCRYPTION_ALGORITHM}

		# The encryption salt used.
		# Only for "AES_256_PBE_CBC" and "AES_256_PBE_GCM".
		salt: "5c0744940b5c369b"
		salt: ${?KCRUD_SECURITY_ENCRYPTION_SALT}

		# The encryption key used.
		key: "kcrud-secret-key-example"
		key: ${?KCRUD_SECURITY_ENCRYPTION_KEY}

		# The encryption initialization vector used.
		sign: "kcrud-secret-sign-example"
		sign: ${?KCRUD_SECURITY_ENCRYPTION_SIGN}
	}

	# Constraints to be use for endpoints rate limiting.
	constraints {
		publicApi {
			# Maximum number of requests allowed for the Public API.
			# Default is 2000 requests per second.
			limit: 10000
			limit: ${?KCRUD_SECURITY_CONSTRAINTS_PUBLIC_API_LIMIT}
			refillMs: 1000 # 1 second.
			refillMs: ${?KCRUD_SECURITY_CONSTRAINTS_PUBLIC_API_REFILL_MS}
		}

		newToken {
			# Maximum number of requests allowed for a New Authentication Token generation.
			# Default is 100 requests every 10 seconds.
			limit: 1000
			limit: ${?KCRUD_SECURITY_CONSTRAINTS_NEW_TOKEN_LIMIT}
			refillMs: 10000 # 10 seconds.
			refillMs: ${?KCRUD_SECURITY_CONSTRAINTS_NEW_TOKEN_REFILL_MS}
		}
	}
}
